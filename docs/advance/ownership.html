

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-TW">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>所有權 &#8212; Rust 程式設計從頭開始 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="物件導向程式設計" href="oop.html" />
    <link rel="prev" title="字串" href="../basic/string.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="oop.html" title="物件導向程式設計"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="../basic/string.html" title="字串"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Rust 程式設計從頭開始 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">所有權</a><ul>
<li><a class="reference internal" href="#id2">指標與參考</a></li>
<li><a class="reference internal" href="#id3">所有權</a></li>
<li><a class="reference internal" href="#borrowing">Borrowing</a></li>
<li><a class="reference internal" href="#lifetime">Lifetime</a><ul>
<li><a class="reference internal" href="#id4">Lifetime 所要處理的問題</a></li>
<li><a class="reference internal" href="#id5">指明 lifetime</a></li>
<li><a class="reference internal" href="#static">static</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../basic/string.html"
                        title="previous chapter">字串</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="oop.html"
                        title="next chapter">物件導向程式設計</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/advance/ownership.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>所有權<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p><strong>所有權 (ownership)</strong> 是 Rust 的核心概念之一，在許多主流語言中沒有強調所有權的觀念，而 Rust 從一開始就放入這個概念，Rust 的安全性和所有權的概念息息相關，但是，這也是 Rust 難以上手的原因。雖然 Rust 官方文件沒有強調<strong>參考 (reference)</strong>的概念，不過，了解參考，對於了解所有權有相當的幫助。</p>
<p><em>註：Rust 的參考類似 C/C++ 的指標。</em></p>
<div class="section" id="id2">
<h2>指標與參考<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><strong>指標 (pointer)</strong> 本身的值不是資料，而是指向另一個資料的記憶體位置。如下圖：</p>
<img alt="指標" src="../_images/pointer.png" />
<p>由於指標本身是整數，透過傳遞指標，不需要拷貝整個原始資料，若資料量較大時，傳遞指標可使得程式更有效率。</p>
<p>不同語言對指標的處理方式大異其趣，C 或 C++ 給使用者很大的自由，讓使用者自行操作指標，而許多高階語言將指標隱藏起來，使用者完全不會碰觸到指標。Rust 則介於兩者之間，雖然平常不需要指標，需要時，Rust 讓使用者有操作指標的自由。</p>
<p>以下是一個 C 語言的例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="c1">// Get the address of n</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">n_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>

    <span class="c1">// Dereference n_ptr to get n</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">n_ptr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以 Rust 撰寫類似的代碼：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get the reference of n</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span><span class="w">  </span><span class="c1">// &amp; i32</span>

<span class="w">    </span><span class="c1">// Dereference n_ref to get n</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">n_ref</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在本程式中，<code class="docutils literal"><span class="pre">n_ref</span></code> 的型別是 <code class="docutils literal"><span class="pre">&amp;</span> <span class="pre">i32</span></code>，意思是「指向 <code class="docutils literal"><span class="pre">i32</span></code> 型別的<strong>參考 (reference)</strong>」，但其觀念上相當接近指標。</p>
<p>以下是另一個 C++ 中使用指標的例子：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

    <span class="c1">// Modify vec in-place!</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Print out the data of vec in console</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在本程式中，我們取得 <code class="docutils literal"><span class="pre">vec</span></code> 的元素的指標，解址取得其值，處理後再存回該元素中。以上例子改寫成類似的 Rust 程式碼如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Modify vec in-place!</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Print out the data of vec in console</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>同樣地，我們得到該 vector 的參考，解參考取得其值，處理後再存回該元素中。</p>
<p>接下來，我們開始探討 Rust 的所有權。</p>
</div>
<div class="section" id="id3">
<h2>所有權<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>C 和 C++ 給使用者較大的自由，但對某些指標使用造成的問題，沒有特定的規範。我們來看一個 C 語言的<strong>迷途指標 (dangling pointer)</strong> 的例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// Allocate memory for the array a.</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="c1">// Set the value in a</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Share the address of a to a1</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="c1">// Oh, the memory of a is freed!</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Now a1 becomes dangling pointer.</span>
<span class="cm">       Accessing data via a dangling pointer is</span>
<span class="cm">       an undefined behavior. */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a1</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>簡單地說，<code class="docutils literal"><span class="pre">a</span></code> 和 <code class="docutils literal"><span class="pre">a1</span></code> 指向同一塊記憶體區塊，在釋放 <code class="docutils literal"><span class="pre">a</span></code> 的記憶體後，<code class="docutils literal"><span class="pre">a1</span></code> 變成迷途指標 (dangling pointer)。在 C 或 C++ 中，沒有規範如何處理這樣的行為，而 Rust 以 <strong>所有權 (ownership)</strong> 來處理這個問題。見以下程式碼：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Vector moved from v to v1</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Error when accessing v</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>這個程式引發了以下錯誤：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">error[E0382]: use of moved value: `v`</span>
</pre></div>
</div>
<p>以及以下附註：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait</span>
</pre></div>
</div>
<p>在本程式中，為了避免 <code class="docutils literal"><span class="pre">v</span></code> 和 <code class="docutils literal"><span class="pre">v1</span></code> 存取同一塊記憶體後，因釋放記憶體而造成迷途指標的問題，Rust 將 <code class="docutils literal"><span class="pre">v</span></code> 的所有權轉移到 <code class="docutils literal"><span class="pre">v1</span></code>，來避免這個問題發生。然而，以下的程式卻可正常運行：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy x into x1</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// No error when accessing x</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>這是因為 Rust 將 <code class="docutils literal"><span class="pre">x</span></code> 的值拷貝一份到 <code class="docutils literal"><span class="pre">x1</span></code>，故不會有前述問題發生。</p>
<p>在使用函式時，也會發生同樣的狀況。見以下程式：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// v is moved into do_nothing</span>
<span class="w">    </span><span class="n">do_nothing</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Error when accessing v</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">do_nothing</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do nothing here.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>以下程式，同樣引發以下錯誤：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">error[E0382]: use of moved value: `v`</span>
</pre></div>
</div>
<p>在本程式中，即使我們對 <code class="docutils literal"><span class="pre">v</span></code> 沒有進行任何實質的操作，仍然發生了所有權轉移的問題。為了處理上述問題，Rust 引入 borrowing 的機制，也就是我們下文要討論的內容。</p>
</div>
<div class="section" id="borrowing">
<h2>Borrowing<a class="headerlink" href="#borrowing" title="Permalink to this headline">¶</a></h2>
<p>承接上節的內容，我們來看一個 borrowing 的例子：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Borrow v to sum</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// v is still accessible</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">sum</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在本程式中，Rust 將 <code class="docutils literal"><span class="pre">v</span></code> 的所有權暫時借給 <code class="docutils literal"><span class="pre">sum</span></code> 之中，待函式運行結束後，再將所有權轉回 <code class="docutils literal"><span class="pre">v</span></code>，使得所有權的機制可正常運行。在其他語言中，也有類似的概念，像是 C++ 的參考 (reference)。將以上程式以 C++ 重新改寫如下：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

    <span class="c1">// Pass the reference of vec into sum</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在本程式中，我們沒有拷貝整個 <code class="docutils literal"><span class="pre">vec</span></code>，而是將其位址傳入 <code class="docutils literal"><span class="pre">sum</span></code>。不過，在 C++ 程式中，並沒有強調所有權的概念。</p>
<p><em>註：C++ 的參考和 Rust 的參考是不同的概念。</em></p>
<p>結合我們先前談的可變性的概念，如果我們要在轉移參數所有權後修改其值，必需要明確地指定可變性。例如，以下的程式會引發錯誤：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Try to modify vec in-place</span>
<span class="w">    </span><span class="n">square_each</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">square_each</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>本程式造成以下的錯誤：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">error: cannot borrow immutable borrowed content `*v` as mutable</span>
</pre></div>
</div>
<p>若將程式進行適當的修改，則可正確執行。範例如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Modify vec in-place!</span>
<span class="w">    </span><span class="n">square_each</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">square_each</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>雖然以上程式可正確執行，但卻不是一個良好的模式，因為這個程式對 <code class="docutils literal"><span class="pre">vec</span></code> 造成了<strong>副作用 (side effect)</strong>，也就是說，這個程式會更動 <code class="docutils literal"><span class="pre">vec</span></code> 的狀態。當然，並不是絕對不能用這樣的方式寫程式，只是，要思考一下，這樣子的效果是否是自己想要的。</p>
</div>
<div class="section" id="lifetime">
<h2>Lifetime<a class="headerlink" href="#lifetime" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>Lifetime 所要處理的問題<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>假設以下的情形：</p>
<ol class="arabic simple">
<li>A 取得資源</li>
<li>A 將資源的所有權借給 B</li>
<li>A 將資源釋放掉</li>
<li>B 欲取得資源，造成程式錯誤</li>
</ol>
<p>而 Rust 透過 lifetime 避免以上問題。如以下範例：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Borrow n to y</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Transfer the ownership from y to x</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"> </span><span class="c1">// n lives until here</span>

<span class="w">     </span><span class="c1">// n is no longer available.</span>
<span class="w">     </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>本程式造成以下錯誤：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">error: `n` does not live long enough</span>
</pre></div>
</div>
<p>在本程式中，<code class="docutils literal"><span class="pre">y</span></code> 向 <code class="docutils literal"><span class="pre">n</span></code> 借得所有權後，將其轉給 <code class="docutils literal"><span class="pre">x</span></code>。但在該區塊結束後，<code class="docutils literal"><span class="pre">n</span></code> 的 lifetime 已經結束，實質上已經無法取得 <code class="docutils literal"><span class="pre">n</span></code>，而 Rust 偵測到這個問題並在編譯程式時引發相關的錯誤。然而，在 C 或 C++，卻沒有規範上述行為，見以下範例：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="c1">// n become alive here</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

        <span class="c1">// Get the address of n</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>

        <span class="c1">// Share the address of n to x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// n lives until here</span>

    <span class="c1">// Now, assess n, which is no longer alive</span>
    <span class="c1">// The behavior is undefined.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>筆者實測，此程式印出 0，但不同電腦上，可能結果不同，而程式設計者不應依賴其結果。由此例可見 Rust 和 C 或 C++ 在設計上的相異點。</p>
</div>
<div class="section" id="id5">
<h3>指明 lifetime<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>其實在撰寫函式時，也隱藏著 lifetime 的概念。像是以下的函式</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do something</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>若明確指明 lifetime 則變成</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do something</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>若參數是可變的，則變成</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Do something</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中的 <code class="docutils literal"><span class="pre">'a</span></code> 是一個代稱，代表的是 <code class="docutils literal"><span class="pre">foo</span></code> 函式的 lifetime，而 <code class="docutils literal"><span class="pre">'a</span></code> 不是固定的，可以換成其他的字。由於我們到目前為止，都沒有明確寫出 lifetime，讀者可能會感到困惑，這是由於 Rust 自動推斷 lifetime 的功能 (lifetime elision)，藉此減少使用者輸入。</p>
<p>如果 struct 內的屬性有參考，也要明確指明 lifetime，如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="static">
<h3>static<a class="headerlink" href="#static" title="Permalink to this headline">¶</a></h3>
<p>static 是一個特別的 lifetime 修飾，表示該變數的 lifetime 為整個程式。如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello, World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>也可用在常數，如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">FOO</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FOO</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="oop.html" title="物件導向程式設計"
             >next</a></li>
        <li class="right" >
          <a href="../basic/string.html" title="字串"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Rust 程式設計從頭開始 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> Michael Chen, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>