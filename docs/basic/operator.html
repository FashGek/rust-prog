

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-TW">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>運算子 &#8212; Rust 程式設計從頭開始 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="控制流程" href="control_flow.html" />
    <link rel="prev" title="變數和型別" href="variable_type.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="control_flow.html" title="控制流程"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="variable_type.html" title="變數和型別"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Rust 程式設計從頭開始 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">運算子</a><ul>
<li><a class="reference internal" href="#id2">代數運算子</a></li>
<li><a class="reference internal" href="#bitwise">Bitwise 運算子</a></li>
<li><a class="reference internal" href="#id3">比較運算子</a></li>
<li><a class="reference internal" href="#id4">布林運算子</a></li>
<li><a class="reference internal" href="#id5">轉型運算子</a></li>
<li><a class="reference internal" href="#id6">指派運算子</a></li>
<li><a class="reference internal" href="#id7">複合指派運算子</a></li>
<li><a class="reference internal" href="#id8">其他運算子</a></li>
<li><a class="reference internal" href="#id9">運算子優先順序</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="variable_type.html"
                        title="previous chapter">變數和型別</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="control_flow.html"
                        title="next chapter">控制流程</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/basic/operator.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>運算子<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>本章介紹運算子，這些運算子是 Rust 中實際執行工作的基礎元件。運算子間可相互組合，達到更複雜的效果。</p>
<p>Rust 包括以下運算子：</p>
<ul class="simple">
<li>代數運算子</li>
<li>bitwise 運算子</li>
<li>比較運算子</li>
<li>布林運算子</li>
<li>轉型運算子</li>
<li>指派運算子</li>
<li>複合指派運算子</li>
<li>其他運算子</li>
</ul>
<p>本章將逐一介紹這些運算子。</p>
<div class="section" id="id2">
<h2>代數運算子<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>包括加 <code class="docutils literal"><span class="pre">+</span></code>、減 <code class="docutils literal"><span class="pre">-</span></code>、乘 <code class="docutils literal"><span class="pre">*</span></code>、除 <code class="docutils literal"><span class="pre">/</span></code>、取餘數 <code class="docutils literal"><span class="pre">%</span></code> 等運算子。</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在本例中，我們使用 <code class="docutils literal"><span class="pre">assert_eq!</span></code> 代替 <code class="docutils literal"><span class="pre">println!</span></code>，這個函式在程式兩邊不相等時會引發錯誤，好處是由程式替我們檢查值是否正確，而不需人工確認。本書中部分代碼會使用這種風格來表示。</p>
<p>然而，由於電腦的限制，浮點數在電腦內的表示是不精確的。例如，<code class="docutils literal"><span class="pre">0.3</span> <span class="pre">-</span> <span class="pre">0.2</span></code> 的結果
不會剛好是 <code class="docutils literal"><span class="pre">0.1</span></code> 而有一個微小的誤差。見以下範例：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mf">0.3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>本程式引發了以下錯誤，表示浮點數的運算是不精確的。</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">thread &#39;main&#39; panicked at &#39;assertion failed:</span>
<span class="go">`(left == right)` (left: `0.09999999999999998`, right: `0.1`)&#39;</span>
</pre></div>
</div>
<p>比較好的方法，是比較兩數相減的誤差的絕對值。見以下範例：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="kt">f64</span><span class="o">::</span><span class="n">abs</span><span class="p">((</span><span class="mf">0.3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-10</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>本程式即可順利執行。在本程式中，我們使用 <code class="docutils literal"><span class="pre">assert!</span></code>，這個函式在其內條件式不為真時引發錯誤，使用方式類似 <code class="docutils literal"><span class="pre">assert_eq!</span></code>。</p>
</div>
<div class="section" id="bitwise">
<h2>Bitwise 運算子<a class="headerlink" href="#bitwise" title="Permalink to this headline">¶</a></h2>
<p>包括 bitwise AND <code class="docutils literal"><span class="pre">&amp;</span></code>、bitwise inclusive OR <code class="docutils literal"><span class="pre">|</span></code>、bitwise exclusive OR <code class="docutils literal"><span class="pre">^</span></code>、左移 <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>、右移 <code class="docutils literal"><span class="pre">&gt;&gt;</span></code> 等運算子。Bitwise 運算是以二進位數來運算，和平常使用的十進位數不同，有興趣的讀者可參考計算機概論等相關書籍。</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mb">0b0011</span><span class="k">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mb">0b0101</span><span class="p">,</span><span class="w"> </span><span class="mb">0b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mb">0b0011</span><span class="k">u32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mb">0b0101</span><span class="p">,</span><span class="w"> </span><span class="mb">0b0111</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="k">u32</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>比較運算子<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>對於支援的型別，也可比較其大小。包括等於 <code class="docutils literal"><span class="pre">==</span></code>、不等於 <code class="docutils literal"><span class="pre">!=</span></code>、大於 <code class="docutils literal"><span class="pre">&gt;</span></code>、小於 <code class="docutils literal"><span class="pre">&lt;</span></code>、大於等於 <code class="docutils literal"><span class="pre">&gt;=</span></code>、小於等於 <code class="docutils literal"><span class="pre">&lt;=</span></code> 等運算子。</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>布林運算子<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>布林運算子是用來結合兩個以上的條件式，包括 AND <code class="docutils literal"><span class="pre">&amp;&amp;</span></code>、OR <code class="docutils literal"><span class="pre">||</span></code> 、NOT <code class="docutils literal"><span class="pre">!</span></code> 等。</p>
<p>AND 運算遵守以下邏輯：</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="32%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">p</th>
<th class="head">q</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="row-odd"><td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr class="row-even"><td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr class="row-odd"><td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>OR 運算遵守以下邏輯：</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">p</th>
<th class="head">q</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="row-odd"><td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr class="row-even"><td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr class="row-odd"><td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>NOT 運算遵守以下邏輯：</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">p</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>true</td>
<td>false</td>
</tr>
<tr class="row-odd"><td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>如果覺得記上述表格很困難，只要記得「<em>所有條件為真時，AND 才為真；只要有條件為真時，OR 即為真</em>」。結合上述基本邏輯，可撰寫更複雜的條件敘述。以下為範例：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">assert</span><span class="o">!</span><span class="p">((</span><span class="k">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="kc">false</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>轉型運算子<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>轉型運算子 <code class="docutils literal"><span class="pre">as</span></code> 是用來轉換資料的型別。由於 Rust 的安全設計，不能直接用整數和浮點數相互運算，而要透過明確的轉型，這和大部分的程式語言不同。下列程式看似正確：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="kt">f64</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-10</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>本程式卻引發了以下錯誤：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">error[E0277]: the trait bound `{float}: std::ops::Sub&lt;{integer}&gt;` is not satisfied</span>
</pre></div>
</div>
<p>這個錯誤訊息，包含一個新的概念。在 Rust，運算子是透過 trait 的機制來達成，若沒有實作相關的 trait，則無法進行相關的運算。我們會在後續的章節介紹 trait。</p>
<p>我們將程式改寫如下：</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="kt">f64</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-10</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>經過轉型，本程式為 <code class="docutils literal"><span class="pre">f64</span></code> 型別間的運算，即可正確執行。</p>
</div>
<div class="section" id="id6">
<h2>指派運算子<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>我們已經在前一章看過指派運算子 <code class="docutils literal"><span class="pre">=</span></code> 了，在宣告變數時通常也會一併賦值。</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><em>注意：不要將指派運算子 = 和相等運算子 == 搞混。</em></p>
</div>
<div class="section" id="id7">
<h2>複合指派運算子<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>複合指派運算子是將代數運算子或 bitwise 運子算以及指派運算子合併，簡化程式碼。</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>可以簡化為</p>
<div class="highlight-rust"><div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Compound assignment</span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>其他運算子<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>這裡列出其他筆者未提到的運算子：</p>
<ul class="simple">
<li>負號運算子 <code class="docutils literal"><span class="pre">-</span></code>：將數字的正負號反轉</li>
<li>解參考運算子 <code class="docutils literal"><span class="pre">*</span></code>：得到參考所指向的值</li>
<li>參考運算子 <code class="docutils literal"><span class="pre">&amp;</span></code> 和 <code class="docutils literal"><span class="pre">&amp;</span> <span class="pre">mut</span></code>：得到某個值的參考</li>
</ul>
<p>我們會在後續的章節討論<strong>參考 (reference)</strong>。</p>
<p><em>註：Rust 的參考類似 C/C++ 的指標。</em></p>
</div>
<div class="section" id="id9">
<h2>運算子優先順序<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Rust 運算子的優先順序，由高至低，如下：</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</pre></div>
</div>
<p>筆者不會刻意去記運算子的優先順序。只要在程式碼中減少過度複雜的敘述，即可減少因運算子優先順序造成的混淆。如果某些敘述較複雜，用中括號 <code class="docutils literal"><span class="pre">()</span></code> 將運算優先順序提高即可。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="control_flow.html" title="控制流程"
             >next</a></li>
        <li class="right" >
          <a href="variable_type.html" title="變數和型別"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Rust 程式設計從頭開始 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> Michael Chen, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>